#include "duckdb/catalog/default/default_views.hpp"
#include "duckdb/planner/binder.hpp"
#include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
#include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
#include "duckdb/common/string_util.hpp"

namespace duckdb {

struct DefaultView {
	const char *schema;
	const char *name;
	const char *sql;
};

static const DefaultView internal_views[] = {
    {DEFAULT_SCHEMA, "pragma_database_list", "SELECT database_oid AS seq, database_name AS name, path AS file FROM duckdb_databases() WHERE NOT internal ORDER BY 1"},
    {DEFAULT_SCHEMA, "sqlite_master", "select 'table' \"type\", table_name \"name\", table_name \"tbl_name\", 0 rootpage, sql from duckdb_tables union all select 'view' \"type\", view_name \"name\", view_name \"tbl_name\", 0 rootpage, sql from duckdb_views union all select 'index' \"type\", index_name \"name\", table_name \"tbl_name\", 0 rootpage, sql from duckdb_indexes;"},
    {DEFAULT_SCHEMA, "sqlite_schema", "SELECT * FROM sqlite_master"},
    {DEFAULT_SCHEMA, "sqlite_temp_master", "SELECT * FROM sqlite_master"},
    {DEFAULT_SCHEMA, "sqlite_temp_schema", "SELECT * FROM sqlite_master"},
    {DEFAULT_SCHEMA, "duckdb_constraints", "SELECT * FROM duckdb_constraints()"},
    {DEFAULT_SCHEMA, "duckdb_columns", "SELECT * FROM duckdb_columns() WHERE NOT internal"},
    {DEFAULT_SCHEMA, "duckdb_databases", "SELECT * FROM duckdb_databases() WHERE NOT internal"},
    {DEFAULT_SCHEMA, "duckdb_indexes", "SELECT * FROM duckdb_indexes()"},
    {DEFAULT_SCHEMA, "duckdb_schemas", "SELECT * FROM duckdb_schemas() WHERE NOT internal"},
    {DEFAULT_SCHEMA, "duckdb_tables", "SELECT * FROM duckdb_tables() WHERE NOT internal"},
    {DEFAULT_SCHEMA, "duckdb_types", "SELECT * FROM duckdb_types()"},
    {DEFAULT_SCHEMA, "duckdb_views", "SELECT * FROM duckdb_views() WHERE NOT internal"},

	{"pg_catalog", "pg_aggregate", "SELECT ''::TEXT AS aggfnoid, ''::TEXT AS aggkind, 0::SMALLINT AS aggnumdirectargs, ''::TEXT AS aggtransfn, ''::TEXT AS aggfinalfn, ''::TEXT AS aggcombinefn, ''::TEXT AS aggserialfn, ''::TEXT AS aggdeserialfn, ''::TEXT AS aggmtransfn, ''::TEXT AS aggminvtransfn, ''::TEXT AS aggmfinalfn, false::BOOLEAN AS aggfinalextra, false::BOOLEAN AS aggmfinalextra, ''::TEXT AS aggfinalmodify, ''::TEXT AS aggmfinalmodify, 0::BIGINT AS aggsortop, 0::BIGINT AS aggtranstype, 0::INTEGER AS aggtransspace, 0::BIGINT AS aggmtranstype, 0::INTEGER AS aggmtransspace, ''::TEXT AS agginitval, ''::TEXT AS aggminitval WHERE false"},
	{"pg_catalog", "pg_am", "SELECT 0::BIGINT AS oid, 'art'::TEXT AS amname, ''::TEXT AS amhandler, 'i'::TEXT AS amtype"},
	{"pg_catalog", "pg_amop", "SELECT 0::BIGINT AS oid, 0::BIGINT AS amopfamily, 0::BIGINT AS amoplefttype, 0::BIGINT AS amoprighttype, 0::SMALLINT AS amopstrategy, ''::TEXT AS amoppurpose, 0::BIGINT AS amopopr, 0::BIGINT AS amopmethod, 0::BIGINT AS amopsortfamily WHERE false"},
	{"pg_catalog", "pg_amproc", "SELECT 0::BIGINT AS oid, 0::BIGINT AS amprocfamily, 0::BIGINT AS amproclefttype, 0::BIGINT AS amprocrighttype, 0::SMALLINT AS amprocnum, ''::TEXT AS amproc WHERE false"},
	{"pg_catalog", "pg_attrdef", "SELECT 0::BIGINT AS oid, 0::BIGINT AS adrelid, 0::SMALLINT AS adnum, ''::TEXT AS adbin WHERE false"},
	{"pg_catalog", "pg_attribute", "SELECT table_oid::BIGINT AS attrelid, column_name::TEXT AS attname, data_type_id::BIGINT AS atttypid, 0::SMALLINT AS attlen, column_index::SMALLINT AS attnum, -1::INTEGER AS attcacheoff, (CASE WHEN data_type ilike '%decimal%' THEN numeric_precision * 1000 + numeric_scale ELSE -1 END)::INTEGER AS atttypmod, 0::SMALLINT AS attndims, false::BOOLEAN AS attbyval, 'c'::TEXT AS attalign, 'p'::TEXT AS attstorage, ' '::TEXT AS attcompression, (NOT is_nullable)::BOOLEAN AS attnotnull, (column_default IS NOT NULL)::BOOLEAN AS atthasdef, false::BOOLEAN AS atthasmissing, ''::TEXT AS attidentity, ''::TEXT AS attgenerated, false::BOOLEAN AS attisdropped, true::BOOLEAN AS attislocal, 0::SMALLINT AS attinhcount, 0::SMALLINT AS attstattarget, 0::SMALLINT AS attcollation, NULL::TEXT[] AS attacl, NULL::TEXT[] AS attoptions, NULL::TEXT[] AS attfdwoptions, NULL::TEXT[] AS attmissingval FROM duckdb_columns()"},
	{"pg_catalog", "pg_authid", "SELECT 0::BIGINT AS oid, ''::TEXT AS rolname, false::BOOLEAN AS rolsuper, false::BOOLEAN AS rolinherit, false::BOOLEAN AS rolcreaterole, false::BOOLEAN AS rolcreatedb, false::BOOLEAN AS rolcanlogin, false::BOOLEAN AS rolreplication, false::BOOLEAN AS rolbypassrls, 0::INTEGER AS rolconnlimit, ''::TEXT AS rolpassword, NULL::TIMESTAMPTZ AS rolvaliduntil WHERE false"},
	{"pg_catalog", "pg_auth_members", "SELECT 0::BIGINT AS oid, 0::BIGINT AS roleid, 0::BIGINT AS member, 0::BIGINT AS grantor, false::BOOLEAN AS admin_option, false::BOOLEAN AS inherit_option, false::BOOLEAN AS set_option WHERE false"},
	{"pg_catalog", "pg_cast", "SELECT 0::BIGINT AS oid, 0::BIGINT AS castsource, 0::BIGINT AS casttarget, 0::BIGINT AS castfunc, ''::TEXT AS castcontext, ''::TEXT AS castmethod WHERE false"},
	{"pg_catalog", "pg_class", "SELECT table_oid::BIGINT AS oid, table_name::TEXT AS relname, schema_oid::BIGINT AS relnamespace, 0::BIGINT AS reltype, 0::BIGINT AS reloftype, 0::BIGINT AS relowner, 0::BIGINT AS relam, 0::BIGINT AS relfilenode, 0::BIGINT AS reltablespace, 0::INTEGER AS relpages, estimated_size::FLOAT AS reltuples, 0::INTEGER AS relallvisible, 0::BIGINT AS reltoastrelid, 0::BIGINT AS reltoastidxid, (index_count > 0)::BOOLEAN AS relhasindex, false::BOOLEAN AS relisshared, (CASE WHEN temporary THEN 't' ELSE 'p' END)::TEXT AS relpersistence, 'r'::TEXT AS relkind, column_count::SMALLINT AS relnatts, check_constraint_count::SMALLINT AS relchecks, false::BOOLEAN AS relhasoids, has_primary_key::BOOLEAN AS relhaspkey, false::BOOLEAN AS relhasrules, false::BOOLEAN AS relhastriggers, false::BOOLEAN AS relhassubclass, false::BOOLEAN AS relrowsecurity, true::BOOLEAN AS relispopulated, ' '::TEXT AS relreplident, false::BOOLEAN AS relispartition, 0::BIGINT AS relrewrite, 0::BIGINT AS relfrozenxid, 0::BIGINT AS relminmxid, NULL::TEXT[] AS relacl, NULL::TEXT[] AS reloptions, NULL::TEXT AS relpartbound, 0::BIGINT AS tableoid FROM duckdb_tables() UNION ALL SELECT view_oid::BIGINT AS oid, view_name::TEXT AS relname, schema_oid::BIGINT AS relnamespace, 0::BIGINT AS reltype, 0::BIGINT AS reloftype, 0::BIGINT AS relowner, 0::BIGINT AS relam, 0::BIGINT AS relfilenode, 0::BIGINT AS reltablespace, 0::INTEGER AS relpages, 0::FLOAT AS reltuples, 0::INTEGER AS relallvisible, 0::BIGINT AS reltoastrelid, 0::BIGINT AS reltoastidxid, false::BOOLEAN AS relhasindex, false::BOOLEAN AS relisshared, (CASE WHEN temporary THEN 't' ELSE 'p' END)::TEXT AS relpersistence, 'v'::TEXT AS relkind, column_count::SMALLINT AS relnatts, 0::SMALLINT AS relchecks, false::BOOLEAN AS relhasoids, false::BOOLEAN AS relhaspkey, false::BOOLEAN AS relhasrules, false::BOOLEAN AS relhastriggers, false::BOOLEAN AS relhassubclass, false::BOOLEAN AS relrowsecurity, true::BOOLEAN AS relispopulated, ' '::TEXT AS relreplident, false::BOOLEAN AS relispartition, 0::BIGINT AS relrewrite, 0::BIGINT AS relfrozenxid, 0::BIGINT AS relminmxid, NULL::TEXT[] AS relacl, NULL::TEXT[] AS reloptions, NULL::TEXT AS relpartbound, 0::BIGINT AS tableoid FROM duckdb_views() UNION ALL SELECT sequence_oid::BIGINT AS oid, sequence_name::TEXT AS relname, schema_oid::BIGINT AS relnamespace, 0::BIGINT AS reltype, 0::BIGINT AS reloftype, 0::BIGINT AS relowner, 0::BIGINT AS relam, 0::BIGINT AS relfilenode, 0::BIGINT AS reltablespace, 0::INTEGER AS relpages, 0::FLOAT AS reltuples, 0::INTEGER AS relallvisible, 0::BIGINT AS reltoastrelid, 0::BIGINT AS reltoastidxid, false::BOOLEAN AS relhasindex, false::BOOLEAN AS relisshared, (CASE WHEN temporary THEN 't' ELSE 'p' END)::TEXT AS relpersistence, 'S'::TEXT AS relkind, 1::SMALLINT AS relnatts, 0::SMALLINT AS relchecks, false::BOOLEAN AS relhasoids, false::BOOLEAN AS relhaspkey, false::BOOLEAN AS relhasrules, false::BOOLEAN AS relhastriggers, false::BOOLEAN AS relhassubclass, false::BOOLEAN AS relrowsecurity, true::BOOLEAN AS relispopulated, ' '::TEXT AS relreplident, false::BOOLEAN AS relispartition, 0::BIGINT AS relrewrite, 0::BIGINT AS relfrozenxid, 0::BIGINT AS relminmxid, NULL::TEXT[] AS relacl, NULL::TEXT[] AS reloptions, NULL::TEXT AS relpartbound, 0::BIGINT AS tableoid FROM duckdb_sequences() UNION ALL SELECT index_oid::BIGINT AS oid, index_name::TEXT AS relname, schema_oid::BIGINT AS relnamespace, 0::BIGINT AS reltype, 0::BIGINT AS reloftype, 0::BIGINT AS relowner, 0::BIGINT AS relam, 0::BIGINT AS relfilenode, 0::BIGINT AS reltablespace, 0::INTEGER AS relpages, 0::FLOAT AS reltuples, 0::INTEGER AS relallvisible, 0::BIGINT AS reltoastrelid, 0::BIGINT AS reltoastidxid, false::BOOLEAN AS relhasindex, false::BOOLEAN AS relisshared, 't'::TEXT AS relpersistence, 'S'::TEXT AS relkind, 0::SMALLINT AS relnatts, 0::SMALLINT AS relchecks, false::BOOLEAN AS relhasoids, false::BOOLEAN AS relhaspkey, false::BOOLEAN AS relhasrules, false::BOOLEAN AS relhastriggers, false::BOOLEAN AS relhassubclass, false::BOOLEAN AS relrowsecurity, true::BOOLEAN AS relispopulated, ' '::TEXT AS relreplident, false::BOOLEAN AS relispartition, 0::BIGINT AS relrewrite, 0::BIGINT AS relfrozenxid, 0::BIGINT AS relminmxid, NULL::TEXT[] AS relacl, NULL::TEXT[] AS reloptions, NULL::TEXT AS relpartbound, 0::BIGINT AS tableoid FROM duckdb_indexes()"},
	{"pg_catalog", "pg_collation", "SELECT 0::BIGINT AS oid, ''::TEXT AS collname, ''::TEXT AS collnamespace, ''::TEXT AS collowner, ''::TEXT AS collprovider, false::BOOLEAN AS collisdeterministic, ''::TEXT AS collcollate, ''::TEXT AS collctype, ''::TEXT AS collversion, ''::TEXT AS collisdefault, ''::TEXT AS collisshared WHERE false"},
	{"pg_catalog", "pg_constraint", "SELECT (table_oid * 1000000 + constraint_index)::BIGINT AS oid, constraint_text::TEXT AS conname, schema_oid::BIGINT AS connamespace, (CASE constraint_type WHEN 'CHECK' then 'c' WHEN 'UNIQUE' then 'u' WHEN 'PRIMARY KEY' THEN 'p' WHEN 'FOREIGN KEY' THEN 'f' ELSE 'x' END)::TEXT AS contype, false::BOOLEAN AS condeferrable, false::BOOLEAN AS condeferred, true::BOOLEAN AS convalidated, table_oid::BIGINT AS conrelid, 0::BIGINT AS contypid, 0::BIGINT AS conindid, 0::BIGINT AS conparentid, 0::BIGINT AS confrelid, 'a'::TEXT AS confupdtype, 'a'::TEXT AS confdeltype, 's'::TEXT AS confmatchtype, true::BOOLEAN AS conislocal, 0::SMALLINT AS coninhcount, false::BOOLEAN AS connoinherit, constraint_column_indexes::SMALLINT[] AS conkey, NULL::SMALLINT[] AS confkey, NULL::BIGINT[] AS conpfeqop, NULL::BIGINT[] AS conppeqop, NULL::BIGINT[] AS conffeqop, NULL::SMALLINT[] AS conexclop, expression::TEXT AS conbin FROM duckdb_constraints()"},
	{"pg_catalog", "pg_conversion", "SELECT 0::BIGINT AS oid, ''::TEXT AS conname, 0::BIGINT AS connamespace, 0::BIGINT AS conowner, ''::TEXT AS conforencoding, ''::TEXT AS contoencoding, ''::TEXT AS conproc, false::BOOLEAN AS condefault WHERE false"},
	{"pg_catalog", "pg_database", "SELECT database_oid::BIGINT AS oid, database_name::TEXT AS datname, 0::BIGINT AS datdba, 0::INTEGER AS encoding, 'c'::TEXT AS datlocprovider, false AS datistemplate, true AS datallowconn, 0 AS datconnlimit, 0::BIGINT AS datfrozenxid, 0::BIGINT AS datminmxid, 0::BIGINT AS dattablespace, ''::TEXT AS datcollate, ''::TEXT AS datctype, NULL::TEXT AS daticulocale, NULL::TEXT AS daticurules, NULL::TEXT AS datcollversion, NULL::TEXT[] AS datacl FROM duckdb_databases()"},
	{"pg_catalog", "pg_db_role_setting", "SELECT 0::BIGINT AS oid, 0::BIGINT AS setrole, 0::BIGINT AS setdatabase, ''::TEXT AS setconfig WHERE false"},
	{"pg_catalog", "pg_default_acl", "SELECT 0::BIGINT AS oid, 0::BIGINT AS defaclrole, 0::BIGINT AS defaclnamespace, ''::TEXT AS defaclobjtype, []::TEXT[] AS defaclacl WHERE false"},
	{"pg_catalog", "pg_depend", "SELECT classid::BIGINT, objid::BIGINT, objsubid::INTEGER, refclassid::BIGINT, refobjid::BIGINT, refobjsubid::INTEGER, deptype::TEXT FROM duckdb_dependencies()"},
	{"pg_catalog", "pg_description", "SELECT table_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, 0::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_tables() WHERE NOT internal UNION ALL SELECT table_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, column_index::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_columns() WHERE NOT internal UNION ALL SELECT view_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, 0::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_views() WHERE NOT internal UNION ALL SELECT index_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, 0::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_indexes() UNION ALL SELECT sequence_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, 0::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_sequences() UNION ALL SELECT type_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, 0::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_types() WHERE type_oid IS NOT NULL UNION ALL SELECT function_oid::BIGINT AS objoid, database_oid::BIGINT AS classoid, 0::INTEGER AS objsubid, comment::TEXT AS description FROM duckdb_functions() WHERE NOT internal"},
	{"pg_catalog", "pg_enum", "SELECT (a.type_oid * 1000 + list_position(b.labels, a.elabel))::BIGINT AS oid, a.type_oid::BIGINT AS enumtypid, (oid - (a.type_oid * 1000))::FLOAT AS enumsortorder, a.elabel::TEXT AS enumlabel FROM (SELECT UNNEST(labels) AS elabel, type_oid FROM duckdb_types() WHERE logical_type = 'ENUM') a JOIN duckdb_types() b ON a.type_oid = b.type_oid"},
	{"pg_catalog", "pg_event_trigger", "SELECT 0::BIGINT AS oid, ''::TEXT AS evtname, ''::TEXT AS evtevent, 0::BIGINT AS evtowner, 0::BIGINT AS evtfoid, ''::TEXT AS evtenabled, NULL::TEXT[] AS evttags WHERE false"},
	{"pg_catalog", "pg_extension", "SELECT 0::BIGINT AS oid, ''::TEXT AS extname, 0::BIGINT AS extowner, 0::BIGINT AS extnamespace, false::BOOLEAN AS extrelocatable, ''::TEXT AS extversion, NULL::BIGINT[] AS extconfig, NULL::TEXT[] AS extcondition WHERE false"},
	{"pg_catalog", "pg_foreign_data_wrapper", "SELECT 0::BIGINT AS oid, ''::TEXT AS fdwname, 0::BIGINT AS fdwowner, 0::BIGINT AS fdwhandler, 0::BIGINT AS fdwvalidator, NULL::TEXT[] AS fdwacl, NULL::TEXT[] AS fdwoptions WHERE false"},
	{"pg_catalog", "pg_foreign_server", "SELECT 0::BIGINT AS oid, ''::TEXT AS srvname, 0::BIGINT AS srvowner, 0::BIGINT AS srvfdw, ''::TEXT AS srvtype, ''::TEXT AS srvversion, NULL::TEXT[] AS srvacl, NULL::TEXT[] AS srvoptions WHERE false"},
	{"pg_catalog", "pg_foreign_table", "SELECT 0::BIGINT AS ftrelid, 0::BIGINT AS ftserver, NULL::TEXT[] AS ftoptions WHERE false"},
	{"pg_catalog", "pg_index", "SELECT index_oid::BIGINT AS indexrelid, table_oid::BIGINT AS indrelid, 0::SMALLINT AS indnatts, 0::SMALLINT AS indnkeyatts, is_unique::BOOLEAN AS indisunique, is_primary::BOOLEAN AS indisprimary, false::BOOLEAN AS indisexclusion, true::BOOLEAN AS indimmediate, false::BOOLEAN AS indisclustered, true::BOOLEAN AS indisvalid, false::BOOLEAN AS indcheckxmin, true::BOOLEAN AS indisready, true::BOOLEAN AS indislive, false::BOOLEAN AS indisreplident, NULL::INT[] AS indkey, NULL::BIGINT[] AS indcollation, NULL::BIGINT[] AS indclass, NULL::INT[] AS indoption, expressions::TEXT AS indexprs, NULL::TEXT AS indpred FROM duckdb_indexes()"},
	{"pg_catalog", "pg_inherits", "SELECT 0::BIGINT AS inhrelid, 0::BIGINT AS inhparent, 0::INTEGER AS inhseqno, false::BOOLEAN AS inhdetachpending WHERE false"},
    {"pg_catalog", "pg_init_privs", "SELECT 0::BIGINT AS objoid, 0::BIGINT AS classoid, 0::INTEGER AS objsubid, ''::TEXT AS privtype, NULL::TEXT[] AS initprivs WHERE false"},
    {"pg_catalog", "pg_language", "SELECT 0::BIGINT AS oid, ''::TEXT AS lanname, 0::BIGINT AS lanowner, false::BOOLEAN AS lanispl, false::BOOLEAN AS lanpltrusted, 0::BIGINT AS lanplcallfoid, 0::BIGINT AS laninline, 0::BIGINT AS lanvalidator, NULL::TEXT[] AS lanacl WHERE false"},
    {"pg_catalog", "pg_largeobject", "SELECT 0::BIGINT AS loid, 0::INTEGER AS pageno, ''::BYTEA AS data WHERE false"},
    {"pg_catalog", "pg_largeobject_metadata", "SELECT 0::BIGINT AS oid, 0::BIGINT AS lomowner, NULL::TEXT[] AS lomacl WHERE false"},
    {"pg_catalog", "pg_namespace", "SELECT oid::BIGINT AS oid, schema_name::TEXT AS nspname, 0::BIGINT AS nspowner, NULL::TEXT[] AS nspacl FROM duckdb_schemas()"},
    {"pg_catalog", "pg_opclass", "SELECT 0::BIGINT AS oid, 0::BIGINT AS opcmethod, ''::TEXT AS opcname, 0::BIGINT AS opcnamespace, 0::BIGINT AS opcowner, 0::BIGINT AS opcfamily, 0::BIGINT AS opcintype, false::BOOLEAN AS opcdefault, 0::BIGINT AS opckeytype WHERE false"},
    {"pg_catalog", "pg_operator", "SELECT 0::BIGINT AS oid, ''::TEXT AS oprname, 0::BIGINT AS oprnamespace, 0::BIGINT AS oprowner, ''::TEXT AS oprkind, false::BOOLEAN AS oprcanmerge, false::BOOLEAN AS oprcanhash, 0::BIGINT AS oprleft, 0::BIGINT AS oprright, 0::BIGINT AS oprresult, 0::BIGINT AS oprcom, 0::BIGINT AS oprnegate, 0::BIGINT AS oprcode, 0::BIGINT AS oprrest, 0::BIGINT AS oprjoin WHERE false"},
    {"pg_catalog", "pg_opfamily", "SELECT 0::BIGINT AS oid, 0::BIGINT AS opfmethod, ''::TEXT AS opfname, 0::BIGINT AS opfnamespace, 0::BIGINT AS opfowner WHERE false"},
    {"pg_catalog", "pg_parameter_acl", "SELECT 0::BIGINT AS oid, ''::BIGINT AS parname, ''::BIGINT[] AS paracl WHERE false"},
    {"pg_catalog", "pg_partitioned_table", "SELECT 0::BIGINT AS partrelid, ''::TEXT AS partstrat, 0::SMALLINT AS partnatts, 0::BIGINT AS partdefid, 0::INT2[] AS partattrs, []::BIGINT[] AS partclass, []::BIGINT[] AS partcollation, ''::TEXT AS partexprs WHERE false"},
    {"pg_catalog", "pg_policy", "SELECT 0::BIGINT AS oid, ''::TEXT AS polname, 0::BIGINT AS polrelid, ''::TEXT AS polcmd, false::BOOLEAN AS polpermissive, []::BIGINT[] AS polroles, ''::TEXT AS polqual, ''::TEXT AS polwithcheck WHERE false"},
	{"pg_catalog", "pg_proc", "SELECT 	f.function_oid::BIGINT AS oid, 	function_name::TEXT AS proname, 	s.oid::BIGINT AS pronamespace, 	0::BIGINT AS proowner, 	0::BIGINT AS prolang, 	0::FLOAT AS procost, 	0::FLOAT AS prorows, 	map_to_pg_oid(lower(varargs))::BIGINT AS provariadic, 	''::TEXT AS prosupport, 	CASE function_type WHEN 'aggregate' THEN 'a' ELSE 'f' END AS prokind, 	false AS prosecdef, 	false AS proleakproof, 	false AS proisstrict, 	function_type = 'table' AS proretset, 	CASE (stability) 		WHEN 'CONSISTENT' THEN 'i' 		WHEN 'CONSISTENT_WITHIN_QUERY' THEN 's' 		WHEN 'VOLATILE' THEN 'v' 		ELSE 's' 	END AS provolatile, 	'u' AS proparallel, 	length(parameters) AS pronargs, 	0 AS pronargdefaults, 	map_to_pg_oid(lower(return_type))::BIGINT AS prorettype, 	list_transform(parameter_types, x -> map_to_pg_oid(lower(x)))::BIGINT[] AS proargtypes, 	NULL::BIGINT[] AS proallargtypes, 	NULL::TEXT[] AS proargmodes, 	parameters::TEXT[] AS proargnames, 	NULL::TEXT AS proargdefaults, 	NULL::BIGINT[] AS protrftypes, 	NULL::TEXT AS prosrc, 	NULL::TEXT AS probin, 	macro_definition::TEXT AS prosqlbody, 	NULL::TEXT[] AS proconfig, 	NULL::TEXT[] AS proacl, 	function_type = 'aggregate' AS proisagg FROM duckdb_functions() f 	LEFT JOIN duckdb_schemas() s 	USING (database_name, schema_name)"},
	{"pg_catalog", "pg_publication", "SELECT 0::BIGINT AS oid, ''::TEXT AS pubname, 0::BIGINT AS pubowner, false AS puballtables, false AS pubinsert, false AS pubupdate, false AS pubdelete, false AS pubtruncate, false AS pubviaroot WHERE false"},
	{"pg_catalog", "pg_publication_namespace", "SELECT 0::BIGINT AS oid, 0::BIGINT AS pnpubid, 0::BIGINT AS pnnspid WHERE false"},
	{"pg_catalog", "pg_publication_rel", "SELECT 0::BIGINT AS oid, 0::BIGINT AS prpubid, 0::BIGINT AS prrelid, NULL::TEXT AS prqual, NULL::SHORT[] AS prattrs WHERE false"},
	{"pg_catalog", "pg_range", "SELECT 0::BIGINT AS rngtypid, 0::BIGINT AS rngsubtype, 0::BIGINT AS rngmultitypid, 0::BIGINT AS rngcollation, 0::BIGINT AS rngsubopc, ''::TEXT AS rngcanonical, ''::TEXT AS rngsubdiff WHERE false"},
	{"pg_catalog", "pg_replication_origin", "SELECT 0::BIGINT AS roident, ''::TEXT AS roname WHERE false"},
	{"pg_catalog", "pg_rewrite", "SELECT 0::BIGINT AS oid, ''::TEXT AS rulename, 0::BIGINT AS ev_class, ''::TEXT AS ev_type, ''::TEXT AS ev_enabled, false::BOOLEAN AS is_instead, ''::TEXT AS ev_qual, ''::TEXT AS ev_action WHERE false"},
	{"pg_catalog", "pg_seclabel", "SELECT 0::BIGINT AS objoid, 0::BIGINT AS classoid, 0::INTEGER AS objsubid, ''::TEXT AS provider, ''::TEXT AS label WHERE false"},
	{"pg_catalog", "pg_sequence", "SELECT sequence_oid AS seqrelid, 0 AS seqtypid, start_value AS seqstart, increment_by AS seqincrement, max_value AS seqmax, min_value AS seqmin, 0 AS seqcache, cycle AS seqcycle FROM duckdb_sequences()"},
	{"pg_catalog", "pg_shdepend", "SELECT 0::BIGINT AS dbid, 0::BIGINT AS classid, 0::BIGINT AS objid, 0::INTEGER AS objsubid, 0::BIGINT AS refclassid, 0::BIGINT AS refobjid, ''::TEXT AS deptype WHERE false"},
	{"pg_catalog", "pg_shdescription", "SELECT 0::BIGINT AS objoid, 0::BIGINT AS classoid, ''::TEXT AS description WHERE false"},
	{"pg_catalog", "pg_shseclabel", "SELECT 0::BIGINT AS objoid, 0::BIGINT AS classoid, ''::TEXT AS provider, ''::TEXT AS label WHERE false"},
	{"pg_catalog", "pg_statistic", "SELECT 0::BIGINT AS starelid, 0::SMALLINT AS staattnum, 0::BOOLEAN AS stainherit, 0::FLOAT AS stanullfrac, 0::INTEGER AS stawidth, 0::FLOAT AS stadistinct, 0::SMALLINT AS stakind1, 0::SMALLINT AS stakind2, 0::SMALLINT AS stakind3, 0::SMALLINT AS stakind4, 0::SMALLINT AS stakind5, 0::BIGINT AS staop1, 0::BIGINT AS staop2, 0::BIGINT AS staop3, 0::BIGINT AS staop4, 0::BIGINT AS staop5, 0::BIGINT AS stacoll1, 0::BIGINT AS stacoll2, 0::BIGINT AS stacoll3, 0::BIGINT AS stacoll4, 0::BIGINT AS stacoll5, []::FLOAT[] AS stanumbers1, []::FLOAT[] AS stanumbers2, []::FLOAT[] AS stanumbers3, []::FLOAT[] AS stanumbers4, []::FLOAT[] AS stanumbers5, []::INT[] AS stavalues1, []::INT[] AS stavalues2, []::INT[] AS stavalues3, []::INT[] AS stavalues4, []::INT[] AS stavalues5 WHERE false"},
	{"pg_catalog", "pg_statistic_ext", "SELECT 0::BIGINT AS oid, 0::BIGINT AS stxrelid, ''::TEXT AS stxname, 0::BIGINT AS stxnamespace, 0::BIGINT AS stxowner, 0::INTEGER AS stxstattarget, []::INTEGER[] AS stxkeys, ''::TEXT[] AS stxkind, ''::BIGINT AS stxexprs WHERE false"},
	{"pg_catalog", "pg_statistic_ext_data", "SELECT 0::BIGINT AS stxoid, false::BOOLEAN AS stxdinherit, NULL::TEXT AS stxdndistinct, NULL::TEXT AS stxddependencies, NULL::TEXT AS stxdmcv, []::TEXT[] AS stxdexpr WHERE false"},
	{"pg_catalog", "pg_subscription", "SELECT 0::BIGINT AS oid, 0::BIGINT AS subdbid, 0::BIGINT AS pg_lsn, ''::TEXT AS subname, 0::BIGINT AS subowner, false::BOOLEAN AS subenabled, false::BOOLEAN AS subbinary, ''::TEXT AS substream, ''::TEXT AS subtwophasestate, false::BOOLEAN AS subdisableonerr, false::BOOLEAN AS subpasswordrequired, false::BOOLEAN AS subrunasowner, ''::TEXT AS subconninfo, ''::TEXT AS subslotname, ''::TEXT AS subsynccommit, []::TEXT[] AS subpublications, ''::TEXT AS suborigin WHERE false"},
	{"pg_catalog", "pg_subscription_rel", "SELECT 0::BIGINT AS srsubid, 0::BIGINT AS srrelid, ''::TEXT AS srsubstate, 0::BIGINT AS srsublsn WHERE false"},
	{"pg_catalog", "pg_tablespace", "SELECT 0::BIGINT AS oid, ''::TEXT AS spcname, 0::BIGINT AS spcowner, NULL::TEXT[] AS spcacl, NULL::TEXT[] AS spcoptions"},
	{"pg_catalog", "pg_transform", "SELECT 0::BIGINT AS oid, 0::BIGINT AS trftype, 0::BIGINT AS trflang, 0::BIGINT AS trffromsql, 0::BIGINT AS trftosql WHERE false"},
	{"pg_catalog", "pg_trigger", "SELECT 0::BIGINT AS oid, 0::BIGINT AS tgrelid, 0::BIGINT AS tgparentid, ''::TEXT AS tgname, 0::BIGINT AS tgfoid, 0::SMALLINT AS tgtype, ''::TEXT AS tgenabled, false::BOOLEAN AS tgisinternal, 0::BIGINT AS tgconstrrelid, 0::BIGINT AS tgconstrindid, 0::BIGINT AS tgconstraint, false::BOOLEAN AS tgdeferrable, false::BOOLEAN AS tginitdeferred, 0::SMALLINT AS tgnargs, ''::INT2[] AS tgattr, ''::BYTEA AS tgargs, NULL::TEXT AS tgqual, ''::TEXT AS tgoldtable, ''::TEXT AS tgnewtable WHERE false"},
	{"pg_catalog", "pg_ts_config", "SELECT 0::BIGINT AS oid, ''::TEXT AS cfgname, 0::BIGINT AS cfgnamespace, 0::BIGINT AS cfgowner, 0::BIGINT AS cfgparser WHERE false"},
	{"pg_catalog", "pg_ts_config_map", "SELECT 0::BIGINT AS mapcfg, 0::INTEGER AS maptokentype, 0::INTEGER AS mapseqno, 0::BIGINT AS mapdict"},
	{"pg_catalog", "pg_ts_dict", "SELECT 0::BIGINT AS oid, ''::TEXT AS dictname, 0::BIGINT AS dictnamespace, 0::BIGINT AS dictowner, 0::BIGINT AS dicttemplate, ''::TEXT AS dictinitoption WHERE false"},
	{"pg_catalog", "pg_ts_parser", "SELECT 0::BIGINT AS oid, ''::TEXT AS prsname, 0::BIGINT AS prsnamespace, 0::BIGINT AS prsstart, 0::BIGINT AS prstoken, 0::BIGINT AS prsend, 0::BIGINT AS prsheadline, 0::BIGINT AS prslextype WHERE false"},
	{"pg_catalog", "pg_ts_template", "SELECT 0::BIGINT AS oid, ''::TEXT AS tmplname, 0::BIGINT AS tmplnamespace, 0::BIGINT AS tmplinit, 0::BIGINT AS tmpllexize WHERE false"},
	{"pg_catalog", "pg_type", "WITH schema AS (SELECT min(oid) AS oid FROM duckdb_schemas() WHERE schema_name = 'pg_catalog') SELECT  col0::BIGINT AS oid,  col1::TEXT AS typname,  schema.oid::BIGINT AS typnamespace,  col3::BIGINT AS typowner,  col4::SMALLINT AS typlen,  col5::BOOLEAN AS typbyval,  col6::TEXT AS typtype,  col7::TEXT AS typcategory,  col8::BOOLEAN AS typispreferred,  col9::BOOLEAN AS typisdefined,  col10::TEXT AS typdelim,  col11::BIGINT AS typrelid,  col12::TEXT AS typsubscript,  col13::BIGINT AS typelem,  col14::BIGINT AS typarray,  col15::TEXT AS typinput,  col16::TEXT AS typoutput,  col17::TEXT AS typreceive,  col18::TEXT AS typsend,  col19::TEXT AS typmodin,  col20::TEXT AS typmodout,  col21::TEXT AS typanalyze,  col22::TEXT AS typalign,  col23::TEXT AS typstorage,  col24::BOOLEAN AS typnotnull,  col25::BIGINT AS typbasetype,  col26::INTEGER AS typtypmod,  col27::INTEGER AS typndims,  col28::BIGINT AS typcollation,  col29::TEXT AS typdefaultbin,  col30::TEXT AS typdefault,  col31::TEXT[] AS typacl  FROM (  VALUES  (16,   'bool',        0, 0,  1, true,  'b', 'B', true,  true, ',', 0, '', 0, 1000, '0', '0', '0', '0', '0', '0', '0', 'c', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (17,   'bytea',       0, 0, -1, false, 'b', 'U', false, true, ',', 0, '', 0, 1001, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0,   0, NULL, NULL, NULL),  (18,   'char',        0, 0,  1, true,  'b', 'Z', false, true, ',', 0, '', 0, 1002, '0', '0', '0', '0', '0', '0', '0', 'c', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (20,   'int8',        0, 0,  8, true,  'b', 'N', false, true, ',', 0, '', 0, 1016, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (21,   'int2',        0, 0,  2, true,  'b', 'N', false, true, ',', 0, '', 0, 1005, '0', '0', '0', '0', '0', '0', '0', 's', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (23,   'int4',        0, 0,  4, true,  'b', 'N', false, true, ',', 0, '', 0, 1007, '0', '0', '0', '0', '0', '0', '0', 'i', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (25,   'text',        0, 0, -1, false, 'b', 'S', true,  true, ',', 0, '', 0, 1009, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0, 100, NULL, NULL, NULL),  (114,  'json',        0, 0, -1, false, 'b', 'U', false, true, ',', 0, '', 0,  199, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0,   0, NULL, NULL, NULL),  (700,  'float4',      0, 0,  4, true,  'b', 'N', false, true, ',', 0, '', 0, 1021, '0', '0', '0', '0', '0', '0', '0', 'i', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (701,  'float8',      0, 0,  8, true,  'b', 'N', true,  true, ',', 0, '', 0, 1022, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (705,  'unknown',     0, 0, -2, false, 'p', 'X', false, true, ',', 0, '', 0,    0, '0', '0', '0', '0', '0', '0', '0', 'c', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1043, 'varchar',     0, 0, -1, false, 'b', 'S', false, true, ',', 0, '', 0, 1015, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0, 100, NULL, NULL, NULL),  (1082, 'date',        0, 0,  4, true,  'b', 'D', false, true, ',', 0, '', 0, 1182, '0', '0', '0', '0', '0', '0', '0', 'i', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1083, 'time',        0, 0,  8, true,  'b', 'D', false, true, ',', 0, '', 0, 1183, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1114, 'timestamp',   0, 0,  8, true,  'b', 'D', false, true, ',', 0, '', 0, 1115, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1184, 'timestamptz', 0, 0,  8, true,  'b', 'D', true,  true, ',', 0, '', 0, 1185, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1186, 'interval',    0, 0, 16, false, 'b', 'T', true,  true, ',', 0, '', 0, 1187, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1266, 'timetz',      0, 0, 12, false, 'b', 'D', false, true, ',', 0, '', 0, 1270, '0', '0', '0', '0', '0', '0', '0', 'd', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1560, 'bit',         0, 0, -1, false, 'b', 'V', false, true, ',', 0, '', 0, 1561, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1562, 'varbit',      0, 0, -1, false, 'b', 'V', true,  true, ',', 0, '', 0, 1563, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0,   0, NULL, NULL, NULL),  (1700, 'numeric',     0, 0, -1, false, 'b', 'N', false, true, ',', 0, '', 0, 1231, '0', '0', '0', '0', '0', '0', '0', 'i', 'm', false, 0, -1, 0,   0, NULL, NULL, NULL),  (2950, 'uuid',        0, 0, 16, false, 'b', 'U', false, true, ',', 0, '', 0, 2951, '0', '0', '0', '0', '0', '0', '0', 'c', 'p', false, 0, -1, 0,   0, NULL, NULL, NULL),  (3802, 'jsonb',       0, 0, -1, false, 'b', 'U', false, true, ',', 0, '', 0, 3807, '0', '0', '0', '0', '0', '0', '0', 'i', 'x', false, 0, -1, 0,   0, NULL, NULL, NULL),  (2249, 'record',      0, 0, -1, false, 'p', 'P', false, true, ',', 0, '', 0, 2287, '0', '0', '0', '0', '0', '0', '0', 'd', 'x', false, 0, -1, 0,   0, NULL, NULL, NULL)  ), schema  UNION ALL  SELECT  (CASE  WHEN type_oid IS NULL THEN NULL  WHEN logical_type = 'ENUM' AND type_name <> 'enum' THEN type_oid  ELSE map_to_pg_oid(type_name)  END)::BIGINT oid,  format_pg_type(logical_type, type_name)::TEXT AS typname,  schema_oid::BIGINT AS typnamespace,  0::BIGINT AS typowner,  type_size::SMALLINT typlen,  false::BOOLEAN typbyval,  (CASE  WHEN logical_type='ENUM' THEN 'e'  ELSE 'b'  END)::TEXT AS typtype,  (CASE  WHEN type_category='NUMERIC' THEN 'N'  WHEN type_category='STRING' THEN 'S'  WHEN type_category='DATETIME' THEN 'D'  WHEN type_category='BOOLEAN' THEN 'B'  WHEN type_category='COMPOSITE' THEN 'C'  WHEN type_category='USER' THEN 'U'  ELSE 'X'  END) typcategory,  false::BOOLEAN AS typispreferred,  true::BOOLEAN AS typisdefined,  ','::TEXT AS typdelim,  0::BIGINT AS typrelid,  ''::TEXT AS typsubscript,  0::BIGINT AS typelem,  0::BIGINT AS typarray,  '0'::TEXT AS typinput,  '0'::TEXT AS typoutput,  '0'::TEXT AS typreceive,  '0'::TEXT AS typsend,  '0'::TEXT AS typmodin,  '0'::TEXT AS typmodout,  '0'::TEXT AS  typanalyze,  'd'''::TEXT AS typalign,  'p'''::TEXT AS typstorage,  false::BOOLEAN typnotnull,  0::BIGINT typbasetype,  -1::INTEGER typtypmod,  0::INTEGER typndims,  ''::TEXT typcollation,  NULL::TEXT typdefaultbin,  NULL::TEXT typdefault,  NULL::TEXT[] typacl  FROM duckdb_types() WHERE oid IS NOT NULL AND oid NOT IN (16, 17, 18, 20, 21, 23, 25, 114, 700, 701, 705, 1043, 1082, 1083, 1114, 1184, 1186, 1266, 1560, 1562, 1700, 2950, 3802, 2249)"},
	{"pg_catalog", "pg_user_mapping", "SELECT 0::BIGINT AS oid, 0::BIGINT AS umuser, 0::BIGINT AS umserver, NULL::TEXT[] AS umoptions WHERE false"},
	{"pg_catalog", "pg_available_extensions", "SELECT extname AS name, ''::TEXT AS default_version, ''::TEXT AS installed_version, ''::TEXT AS comment FROM pg_extension"},
	{"pg_catalog", "pg_available_extension_versions", "SELECT ''::TEXT AS name, ''::TEXT AS version, false::BOOL AS installed, false::BOOL AS superuser, false::BOOL AS trusted, false::BOOL AS relocatable, NULL::TEXT AS schema, NULL::TEXT[] AS requires, ''::TEXT AS comment WHERE false"},
	{"pg_catalog", "pg_backend_memory_contexts", "SELECT ''::TEXT AS name, ''::TEXT AS ident, ''::TEXT AS parent, 0::INT4 AS level, 0::INT8 AS total_bytes, 0::INT8 AS total_nblocks, 0::INT8 AS free_bytes, 0::INT8 AS free_chunks, 0::INT8 AS used_bytes WHERE false"},
	{"pg_catalog", "pg_config", "SELECT ''::TEXT AS name, ''::TEXT AS setting WHERE false"},
	{"pg_catalog", "pg_cursors", "SELECT ''::TEXT AS name, ''::TEXT AS statement, false::BOOL AS is_holdable, false::BOOL AS is_binary, false::BOOL AS is_scrollable, NULL::TIMESTAMPTZ AS creation_time WHERE false"},
	{"pg_catalog", "pg_file_settings", "SELECT ''::TEXT AS sourcefile, 0::INT4 AS sourceline, 0::INT4 AS seqno, ''::TEXT AS name, ''::TEXT AS setting, false::BOOL AS applied, NULL::TEXT AS error WHERE false"},
	{"pg_catalog", "pg_group", "SELECT ''::TEXT AS groname, 0::BIGINT AS grosysid, NULL::BIGINT[] AS grolist WHERE false"},
	{"pg_catalog", "pg_hba_file_rules", "SELECT NULL::INT4 AS rule_number, ''::TEXT AS file_name, NULL::INT4 AS line_number, ''::TEXT AS type, NULL::TEXT[] AS database, NULL::TEXT[] AS user_name, ''::TEXT AS address, ''::TEXT AS netmask, ''::TEXT AS auth_method, NULL::TEXT[] AS options, ''::TEXT AS error WHERE false"},
	{"pg_catalog", "pg_ident_file_mappings", "SELECT NULL::INT4 AS map_number, ''::TEXT AS file_name, NULL::INT4 AS line_number, ''::TEXT AS map_name, ''::TEXT AS sys_name, ''::TEXT AS pg_username, ''::TEXT AS error WHERE false"},
	{"pg_catalog", "pg_indexes", "SELECT schema_name::TEXT AS schemaname, table_name::TEXT AS tablename, index_name::TEXT AS indexname, NULL::BIGINT AS tablespace, sql::TEXT AS indexdef FROM duckdb_indexes()"},
	{"pg_catalog", "pg_locks", "SELECT ''::TEXT AS locktype, NULL::BIGINT AS database, NULL::BIGINT AS relation, NULL::INT4 AS page, NULL::INT2 AS tuple, ''::TEXT AS virtualxid, NULL::BIGINT AS transactionid, NULL::BIGINT AS classid, NULL::BIGINT AS objid, NULL::INT2 AS objsubid, ''::TEXT AS virtualtransaction, NULL::INT4 AS pid, ''::TEXT AS mode, false::BOOL AS granted, false::BOOL AS fastpath, NULL::TIMESTAMPTZ AS waitstart WHERE false"},
	{"pg_catalog", "pg_matviews", "SELECT ''::TEXT AS schemaname, ''::TEXT AS matviewname, ''::TEXT AS matviewowner, ''::TEXT AS tablespace, false::BOOL AS hasindexes, false::BOOL AS ispopulated, ''::TEXT AS definition WHERE false"},
	{"pg_catalog", "pg_policies", "SELECT ''::TEXT AS schemaname, ''::TEXT AS tablename, ''::TEXT AS policyname, ''::TEXT AS permissive, NULL::TEXT[] AS roles, ''::TEXT AS cmd, ''::TEXT AS qual, ''::TEXT AS with_check WHERE false"},
	{"pg_catalog", "pg_prepared_statements", "SELECT ''::TEXT AS name, ''::TEXT AS statement, NULL::TIMESTAMPTZ AS prepare_time, NULL::BIGINT[] AS parameter_types, NULL::BIGINT[] AS result_types, false::BOOL AS from_sql, 0::INT8 AS generic_plans, 0::INT8 AS custom_plans WHERE false"},
	{"pg_catalog", "pg_prepared_xacts", "SELECT NULL::BIGINT AS transaction, ''::TEXT AS gid, NULL::TIMESTAMPTZ AS prepared, ''::TEXT AS owner, ''::TEXT AS database WHERE false"},
	{"pg_catalog", "pg_publication_tables", "SELECT ''::TEXT AS pubname, ''::TEXT AS schemaname, ''::TEXT AS tablename, NULL::TEXT[] AS attnames, ''::TEXT AS rowfilter WHERE false"},
	{"pg_catalog", "pg_replication_origin_status", "SELECT NULL::BIGINT AS local_id, ''::TEXT AS external_id, NULL::BIGINT AS remote_lsn, NULL::BIGINT AS local_lsn WHERE false"},
	{"pg_catalog", "pg_replication_slots", "SELECT ''::TEXT AS slot_name, ''::TEXT AS plugin, ''::TEXT AS slot_type, NULL::BIGINT AS datoid, ''::TEXT AS database, false::BOOL AS temporary, false::BOOL AS active, NULL::INT4 AS active_pid, NULL::BIGINT AS xmin, NULL::BIGINT AS catalog_xmin, NULL::BIGINT AS restart_lsn, NULL::BIGINT AS confirmed_flush_lsn, ''::TEXT AS wal_status, NULL::INT8 AS safe_wal_size, false::BOOL AS two_phase, false::BOOL AS conflicting WHERE false"},
	{"pg_catalog", "pg_roles", "SELECT ''::TEXT AS rolname, false::BOOL AS rolsuper, false::BOOL AS rolinherit, false::BOOL AS rolcreaterole, false::BOOL AS rolcreatedb, false::BOOL AS rolcanlogin, false::BOOL AS rolreplication, NULL::INT4 AS rolconnlimit, '********'::TEXT AS rolpassword, NULL::TIMESTAMPTZ AS rolvaliduntil, false::BOOL AS rolbypassrls, NULL::TEXT[] AS rolconfig, NULL::BIGINT AS oid WHERE false"},
	{"pg_catalog", "pg_rules", "SELECT ''::TEXT AS schemaname, ''::TEXT AS tablename, ''::TEXT AS rulename, ''::TEXT AS definition WHERE false"},
	{"pg_catalog", "pg_seclabels", "SELECT NULL::BIGINT AS objoid, NULL::BIGINT AS classoid, NULL::INT4 AS objsubid, ''::TEXT AS objtype, NULL::BIGINT AS objnamespace, ''::TEXT AS objname, ''::TEXT AS provider, ''::TEXT AS label WHERE false"},
	{"pg_catalog", "pg_sequences", "SELECT schema_name::TEXT AS schemaname, sequence_name::TEXT AS sequencename, 'duckdb'::TEXT AS sequenceowner, ''::TEXT AS data_type, start_value::BIGINT AS start_value, min_value::BIGINT AS min_value, max_value::BIGINT AS max_value, increment_by::BIGINT AS increment_by, cycle::BOOL AS cycle, 0::BIGINT AS cache_size, last_value::BIGINT AS last_value FROM duckdb_sequences()"},
	{"pg_catalog", "pg_settings", "SELECT name::TEXT AS name, value::TEXT AS setting, ''::TEXT AS unit, ''::TEXT AS category, description::TEXT AS short_desc, ''::TEXT AS extra_desc, ''::TEXT AS context, (CASE WHEN input_type = 'VARCHAR' THEN 'string' WHEN input_type = 'BOOLEAN' THEN 'bool' WHEN input_type IN ('BIGINT', 'UBIGINT') THEN 'integer' ELSE input_type END)::TEXT AS vartype, ''::TEXT AS source, NULL::TEXT AS min_val, NULL::TEXT AS max_val, NULL::TEXT[] AS enumvals, ''::TEXT AS boot_val, ''::TEXT AS reset_val, NULL::TEXT AS sourcefile, NULL::INT4 AS sourceline, false::BOOL AS pending_restart FROM duckdb_settings()"},
	{"pg_catalog", "pg_shadow", "SELECT ''::TEXT AS usename, NULL::BIGINT AS usesysid, false::BOOL AS usecreatedb, false::BOOL AS usesuper, false::BOOL AS userepl, false::BOOL AS usebypassrls, NULL::TEXT AS passwd, NULL::TIMESTAMPTZ AS valuntil, NULL::TEXT[] AS useconfig WHERE false"},
	{"pg_catalog", "pg_shmem_allocations", "SELECT NULL::TEXT AS name, NULL::BIGINT AS off, NULL::BIGINT AS size, NULL::BIGINT AS allocated_size WHERE false"},
	{"pg_catalog", "pg_stats", "SELECT NULL::TEXT AS schemaname, NULL::TEXT AS tablename, NULL::TEXT AS attname, false::BOOL AS inherited, NULL::FLOAT4 AS null_frac, NULL::INT4 AS avg_width, NULL::FLOAT4 AS n_distinct, NULL::TEXT[] AS most_common_vals, NULL::FLOAT4[] AS most_common_freqs, NULL::TEXT[] AS histogram_bounds, NULL::FLOAT4 AS correlation, NULL::TEXT[] AS most_common_elems, NULL::FLOAT4[] AS most_common_elem_freqs, NULL::FLOAT4[] AS elem_count_histogram WHERE false"},
	{"pg_catalog", "pg_stats_ext", "SELECT NULL::TEXT AS schemaname, NULL::TEXT AS tablename, NULL::TEXT AS statistics_schemaname, NULL::TEXT AS statistics_name, NULL::TEXT AS statistics_owner, NULL::TEXT[] AS attnames, NULL::TEXT[] AS exprs, NULL::CHAR[] AS kinds, false::BOOL AS inherited, NULL::TEXT AS n_distinct, NULL::TEXT AS dependencies, NULL::TEXT[] AS most_common_vals, NULL::BOOL[] AS most_common_val_nulls, NULL::FLOAT8[] AS most_common_freqs, NULL::FLOAT8[] AS most_common_base_freqs WHERE false"},
	{"pg_catalog", "pg_stats_ext_exprs", "SELECT NULL::TEXT AS schemaname, NULL::TEXT AS tablename, NULL::TEXT AS statistics_schemaname, NULL::TEXT AS statistics_name, NULL::TEXT AS statistics_owner, NULL::TEXT AS expr, false::BOOLEAN AS inherited, NULL::FLOAT AS null_frac, NULL::INTEGER AS avg_width, NULL::FLOAT AS n_distinct, NULL::TEXT[] AS most_common_vals, NULL::FLOAT[] AS most_common_freqs, NULL::TEXT[] AS histogram_bounds, NULL::FLOAT AS correlation, NULL::TEXT[] AS most_common_elems, NULL::FLOAT[] AS most_common_elem_freqs, NULL::FLOAT[] AS elem_count_histogram WHERE false"},
	{"pg_catalog", "pg_tables", "SELECT schema_name::TEXT AS schemaname, table_name::TEXT AS tablename, 'duckdb'::TEXT AS tableowner, NULL::TEXT AS tablespace, (index_count > 0)::BOOL AS hasindexes, false::BOOL AS hasrules, false::BOOL AS hastriggers, false::BOOL AS rowsecurity FROM duckdb_tables()"},
	{"pg_catalog", "pg_timezone_abbrevs", "SELECT ''::TEXT AS abbrev, '0 seconds'::INTERVAL AS utc_offset, false::BOOL AS is_dst WHERE false"},
	{"pg_catalog", "pg_timezone_names", "SELECT ''::TEXT AS name, ''::TEXT AS abbrev, '0 seconds'::INTERVAL AS utc_offset, false::BOOL AS is_dst WHERE false"},
	{"pg_catalog", "pg_user", "SELECT ''::TEXT AS usename, 0::OID AS usesysid, false::BOOL AS usecreatedb, false::BOOL AS usesuper, false::BOOL AS userepl, false::BOOL AS usebypassrls, ''::TEXT AS passwd, NULL::TIMESTAMPTZ AS valuntil, []::TEXT[] AS useconfig WHERE false"},
	{"pg_catalog", "pg_user_mappings", "SELECT 0::BIGINT AS umid, 0::BIGINT AS srvid, ''::TEXT AS srvname, 0::BIGINT AS umuser, ''::TEXT AS usename, []::TEXT[] AS umoptions WHERE false"},
	{"pg_catalog", "pg_views", "SELECT schema_name::TEXT AS schemaname, view_name::TEXT AS viewname, 'duckdb'::TEXT AS viewowner, sql::TEXT AS definition FROM duckdb_views()"},
	{"information_schema", "columns", "SELECT database_name table_catalog, schema_name table_schema, table_name, column_name, column_index ordinal_position, column_default, CASE WHEN is_nullable THEN 'YES' ELSE 'NO' END is_nullable, data_type, character_maximum_length, NULL::INT character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, NULL::INT datetime_precision, NULL::VARCHAR interval_type, NULL::INT interval_precision, NULL::VARCHAR character_set_catalog, NULL::VARCHAR character_set_schema, NULL::VARCHAR character_set_name, NULL::VARCHAR collation_catalog, NULL::VARCHAR collation_schema, NULL::VARCHAR collation_name, NULL::VARCHAR domain_catalog, NULL::VARCHAR domain_schema, NULL::VARCHAR domain_name, NULL::VARCHAR udt_catalog, NULL::VARCHAR udt_schema, NULL::VARCHAR udt_name, NULL::VARCHAR scope_catalog, NULL::VARCHAR scope_schema, NULL::VARCHAR scope_name, NULL::BIGINT maximum_cardinality, NULL::VARCHAR dtd_identifier, NULL::BOOL is_self_referencing, NULL::BOOL is_identity, NULL::VARCHAR identity_generation, NULL::VARCHAR identity_start, NULL::VARCHAR identity_increment, NULL::VARCHAR identity_maximum, NULL::VARCHAR identity_minimum, NULL::BOOL identity_cycle, NULL::VARCHAR is_generated, NULL::VARCHAR generation_expression, NULL::BOOL is_updatable, comment AS COLUMN_COMMENT FROM duckdb_columns;"},
    {"information_schema", "schemata", "SELECT database_name catalog_name, schema_name, 'duckdb' schema_owner, NULL::VARCHAR default_character_set_catalog, NULL::VARCHAR default_character_set_schema, NULL::VARCHAR default_character_set_name, sql sql_path FROM duckdb_schemas()"},
    {"information_schema", "tables", "SELECT database_name table_catalog, schema_name table_schema, table_name, CASE WHEN temporary THEN 'LOCAL TEMPORARY' ELSE 'BASE TABLE' END table_type, NULL::VARCHAR self_referencing_column_name, NULL::VARCHAR reference_generation, NULL::VARCHAR user_defined_type_catalog, NULL::VARCHAR user_defined_type_schema, NULL::VARCHAR user_defined_type_name, 'YES' is_insertable_into, 'NO' is_typed, CASE WHEN temporary THEN 'PRESERVE' ELSE NULL END commit_action, comment AS TABLE_COMMENT FROM duckdb_tables() UNION ALL SELECT database_name table_catalog, schema_name table_schema, view_name table_name, 'VIEW' table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'NO' is_insertable_into, 'NO' is_typed, NULL commit_action, comment AS TABLE_COMMENT FROM duckdb_views;"},
	{"information_schema", "character_sets", "SELECT NULL::VARCHAR character_set_catalog, NULL::VARCHAR character_set_schema, 'UTF8' character_set_name, 'UCS' character_repertoire, 'UTF8' form_of_use, current_database() default_collate_catalog, 'pg_catalog' default_collate_schema, 'ucs_basic' default_collate_name;"},
	{"information_schema", "referential_constraints", "SELECT f.database_name constraint_catalog, f.schema_name constraint_schema, f.constraint_name constraint_name, c.database_name unique_constraint_catalog, c.schema_name unique_constraint_schema, c.constraint_name unique_constraint_name, 'NONE' match_option, 'NO ACTION' update_rule, 'NO ACTION' delete_rule FROM duckdb_constraints() c, duckdb_constraints() f WHERE f.constraint_type = 'FOREIGN KEY' AND (c.constraint_type = 'UNIQUE' OR c.constraint_type = 'PRIMARY KEY') AND f.database_oid = c.database_oid AND f.schema_oid = c.schema_oid AND lower(f.referenced_table) = lower(c.table_name) AND [lower(x) for x in f.referenced_column_names] = [lower(x) for x in c.constraint_column_names]"},
	{"information_schema", "key_column_usage", "SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, UNNEST(constraint_column_names) column_name, UNNEST(generate_series(1, len(constraint_column_names))) ordinal_position, CASE constraint_type WHEN 'FOREIGN KEY' THEN 1 ELSE NULL END position_in_unique_constraint FROM duckdb_constraints() WHERE constraint_type = 'FOREIGN KEY' OR constraint_type = 'PRIMARY KEY' OR constraint_type = 'UNIQUE';"},
	{"information_schema", "table_constraints", "SELECT database_name constraint_catalog, schema_name constraint_schema, constraint_name, database_name table_catalog, schema_name table_schema, table_name, CASE constraint_type WHEN 'NOT NULL' THEN 'CHECK' ELSE constraint_type END constraint_type, 'NO' is_deferrable, 'NO' initially_deferred, 'YES' enforced, 'YES' nulls_distinct FROM duckdb_constraints() WHERE constraint_type = 'PRIMARY KEY' OR constraint_type = 'FOREIGN KEY' OR constraint_type = 'UNIQUE' OR constraint_type = 'CHECK' OR constraint_type = 'NOT NULL';"},
    {"information_schema", "constraint_column_usage", "SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, column_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, constraint_type, constraint_text FROM (SELECT dc.*, UNNEST(dc.constraint_column_names) AS column_name FROM duckdb_constraints() AS dc WHERE constraint_type NOT IN ('NOT NULL') );"},
    {"information_schema", "constraint_table_usage", "SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, constraint_type FROM duckdb_constraints() WHERE constraint_type NOT IN ('NOT NULL');"},
    {"information_schema", "check_constraints", "SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, CASE constraint_type WHEN 'NOT NULL' THEN column_name || ' IS NOT NULL' ELSE constraint_text END AS check_clause FROM (SELECT dc.*, UNNEST(dc.constraint_column_names) AS column_name FROM duckdb_constraints() AS dc WHERE constraint_type IN ('CHECK', 'NOT NULL'));"},
    {"information_schema", "views", "SELECT database_name AS table_catalog, schema_name AS table_schema, view_name AS table_name, sql AS view_definition, 'NONE' AS check_option, 'NO' AS is_updatable, 'NO' AS is_insertable_into, 'NO' AS is_trigger_updatable, 'NO' AS is_trigger_deletable, 'NO' AS is_trigger_insertable_into FROM duckdb_views();"},
    {nullptr, nullptr, nullptr}};

static unique_ptr<CreateViewInfo> GetDefaultView(ClientContext &context, const string &input_schema, const string &input_name) {
	auto schema = StringUtil::Lower(input_schema);
	auto name = StringUtil::Lower(input_name);
	for (idx_t index = 0; internal_views[index].name != nullptr; index++) {
		if (internal_views[index].schema == schema && internal_views[index].name == name) {
			auto result = make_uniq<CreateViewInfo>();
			result->schema = schema;
			result->view_name = name;
			result->sql = internal_views[index].sql;
			result->temporary = true;
			result->internal = true;

			return CreateViewInfo::FromSelect(context, std::move(result));
		}
	}
	return nullptr;
}

DefaultViewGenerator::DefaultViewGenerator(Catalog &catalog, SchemaCatalogEntry &schema)
    : DefaultGenerator(catalog), schema(schema) {
}

unique_ptr<CatalogEntry> DefaultViewGenerator::CreateDefaultEntry(ClientContext &context, const string &entry_name) {
	auto info = GetDefaultView(context, schema.name, entry_name);
	if (info) {
		return make_uniq_base<CatalogEntry, ViewCatalogEntry>(catalog, schema, *info);
	}
	return nullptr;
}

vector<string> DefaultViewGenerator::GetDefaultEntries() {
	vector<string> result;
	for (idx_t index = 0; internal_views[index].name != nullptr; index++) {
		if (internal_views[index].schema == schema.name) {
			result.emplace_back(internal_views[index].name);
		}
	}
	return result;
}

} // namespace duckdb
